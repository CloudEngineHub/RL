"""Utility functions for 1-D bin-packing.

Currently contains a pure-python implementation of the Johnson & Garey (1985)
Modified First-Fit-Decreasing (MFFD) heuristic.  The implementation operates on
an *offline* list of item sizes and returns a list of bins where each bin keeps
track of the indices of the items assigned to it.  This makes the helper easy
to integrate with code that needs to preserve ordering information.

A minimal public interface is provided via `mffd_pack`.
"""
from __future__ import annotations

from typing import List, Sequence, Tuple

__all__ = ["mffd_pack"]


# -----------------------------------------------------------------------------
# Core algorithm ----------------------------------------------------------------
# -----------------------------------------------------------------------------


def _classify_items(
    items: Sequence[Tuple[int, int]], capacity: int
) -> tuple[
    list[Tuple[int, int]],
    list[Tuple[int, int]],
    list[Tuple[int, int]],
    list[Tuple[int, int]],
]:
    """Split items into large / medium / small / tiny classes.

    Follows the classification used by Johnson & Garey:
        large   : (C/2, C]
        medium  : (C/3, C/2]
        small   : (C/6, C/3]
        tiny    : (0  , C/6]
    Returns the corresponding four lists *without* any additional sorting.
    """
    large, medium, small, tiny = [], [], [], []
    for idx, size in items:
        if size > capacity / 2:
            large.append((idx, size))
        elif size > capacity / 3:
            medium.append((idx, size))
        elif size > capacity / 6:
            small.append((idx, size))
        else:
            tiny.append((idx, size))
    return large, medium, small, tiny


def mffd_pack(lengths: Sequence[int], capacity: int) -> list[list[int]]:  # noqa: C901
    """Run the Johnson & Garey (1985) modified-FFD heuristic.

    Parameters
    ----------
    lengths
        A sequence of non-negative integers representing item sizes.
    capacity
        The bin capacity *C* (must be positive).

    Returns
    -------
    list[list[int]]
        A list of bins.  Each bin is a *list of indices* that refer back to
        the input `lengths` sequence.  The bins are returned in the order they
        are generated by the heuristic.
    """
    if capacity <= 0:
        raise ValueError("capacity must be positive")
    if any(l <= 0 for l in lengths):
        raise ValueError("item lengths must be positive")

    items: list[Tuple[int, int]] = [(i, l) for i, l in enumerate(lengths)]

    # Phase-0: classify
    large, medium, small, tiny = _classify_items(items, capacity)

    # Sort according to the rules of MFFD
    large.sort(key=lambda x: x[1], reverse=True)   # descending size
    medium.sort(key=lambda x: x[1], reverse=True)
    small.sort(key=lambda x: x[1])                 # ascending size
    tiny.sort(key=lambda x: x[1])

    # Phase-1: start one bin per large item ------------------------------------
    bins: list[list[Tuple[int, int]]] = [[item] for item in large]

    # Phase-2: try to add one medium item to each large bin (forward pass) -----
    for b in bins:
        remaining = capacity - sum(size for _, size in b)
        for i, (idx, size) in enumerate(medium):
            if size <= remaining:
                b.append(medium.pop(i))
                break

    # Phase-3: backward pass â€“ fill with two small items where possible --------
    for b in reversed(bins):
        has_medium = any(capacity / 3 < size <= capacity / 2 for _, size in b)
        if has_medium or len(small) < 2:
            continue
        remaining = capacity - sum(size for _, size in b)
        if small[0][1] + small[1][1] > remaining:
            continue
        first_small = small.pop(0)
        # pick the *largest* small that fits with first_small (so iterate from end)
        second_idx = None
        for j in range(len(small) - 1, -1, -1):
            if small[j][1] <= remaining - first_small[1]:
                second_idx = j
                break
        if second_idx is not None:
            second_small = small.pop(second_idx)
            b.extend([first_small, second_small])

    # Phase-4: forward greedy fit of remaining items ---------------------------
    remaining_items = sorted(medium + small + tiny, key=lambda x: x[1], reverse=True)
    for b in bins:
        while remaining_items:
            rem = capacity - sum(size for _, size in b)
            # if even the smallest remaining doesn't fit we break
            if rem < remaining_items[-1][1]:
                break

            # pick the first (largest) that fits
            chosen_idx = None
            for i, (_, size) in enumerate(remaining_items):
                if size <= rem:
                    chosen_idx = i
                    break
            if chosen_idx is None:
                break
            b.append(remaining_items.pop(chosen_idx))

    # Phase-5: FFD on leftovers -----------------------------------------------
    leftovers = remaining_items  # type: ignore # renamed for clarity
    ffd_bins: list[list[Tuple[int, int]]] = []
    for idx, size in sorted(leftovers, key=lambda x: x[1], reverse=True):
        placed = False
        for bin_ffd in ffd_bins:
            if size <= capacity - sum(s for _, s in bin_ffd):
                bin_ffd.append((idx, size))
                placed = True
                break
        if not placed:
            ffd_bins.append([(idx, size)])
    bins.extend(ffd_bins)

    # -------------------------------------------------------------------------
    # Convert to list of index lists (discard sizes) --------------------------
    return [[idx for idx, _ in b] for b in bins] 